调用栈是解释器（比如浏览器中的 JavaScript 解释器）追踪函数执行流的一种机制。当执行环境中调用了多个函数时，通过这种机制，我们能够追踪到哪个函数正在执行，执行的函数体中又调用了哪个函数。

monitoring process 监视进程

* Memory Heap 内存堆 ——  这是内存分配发生的地方

* Call Stack 调用堆栈 ——  这是在你代码执行时栈帧存放的位置

# Web APIs
Dom AJAX Timeout 

# event loop

# Callback Queue

# 1.串行，并行和并发的区别？
- 串行：类似于同步，只有上一个操作完成，才能执行下一个操作
- 并行：同一时间间段可以处理多个线程
- 并发：在同一时间段有多个程序处于开始运行和运行完毕之间的状态，不一定要同时

# 2.js中把图片转换成BASE64格式
根据 base64 的编码原理，大小比原文件大小大 1/3
尽管图片请求少了，但是 HTML 文件本身尺寸会变大，会影响首屏加载，所以要权衡代码看起来会有点丑，大量编码字符（当然也可以通过构建工具动态插入）base64 无法缓存，要缓存只能缓存包含 base64 的文件，比如 HTML 或者 CSS，这相比直接缓存图片要弱很多，一般 HTM 会改动频繁，所以等同于得不到缓存效益

# 3.假设我图片已在浏览器上传，未上传之前想要预览怎么做
   var img_src = URL.createObjectURL(this.files[0]);
            document.getElementById("preview").src=img_src;
# 4.DOCTYPE的作用
  申明文档类型，告诉浏览器以什么文档标准来解析这个文档。
  - 标准模式： 以W3C的标准来解析
  - 怪异模式： 浏览器自己的标准来解析（不加DOCTYPE的时候）
# 5.css画个扇形？

# 6. css中 transtion 和 animate有什么区别？ animate如何停留在最后一帧？
- transition: 一般用来做过度，没有时间轴的概念，通过事件触发（一次），
  没有中间状态（只有开始与结束）
- animate:用来做动效，有时间轴的概念（帧可控），可以重复触发，有中间状态。
fillmode: 动画停止在最后一帧

# 7.js实现String.trim()的方法

# 8. Virtual Dom优势在哪里？
（VDOM解决的问题，以及为什么频繁操作DOM性能差）
  1. js是单线程， 两个执行引擎之间的切换（js引擎与DOM引擎相互独立），
  工作在同一个主线程，只有JS操作DOM时，js引擎就会被挂起，DOM引擎激活工作完毕在切换回JS引擎，所以当有频繁操作DOM代码，两个引擎之间的切换代价很大即性能开销大。
  2. 频繁操作DOM可能引发频繁的回流，重新计算布局和重新绘制图像消耗性能很大。

  VDOM解决：
  1. VDOM不会立马进行回流重绘
  2. 一次性比较VDOM和真实DOM，最后替换真实DOM中需要修改的部分，减少了过多DOM节点的回流重绘损耗
  3. 可以局部渲染，有效减少了大面积真实DOM的回流重绘
# 9. 使用setTimeout模拟setInterval

# 10.给定一个整数数组，找到具有最大和的子数组，返回最大和
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
# script标签可以去写type标签
   async 异步  defer 推迟延缓 之间的区别
   async是异步，当js加载完成就会立即执行
   defer是延迟，等待html解析完成才会执行



