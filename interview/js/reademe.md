因为各种javascript的数据类型最后都会在初始化之后放在不同的内存中，因此上面的数据类型大致可分为两类：

原始数据类型：基础类型存储在栈内存种，被引用或者拷贝时，会创建一个完全相等的变量；占据空间小，大小固定，属于被频繁使用的数据，所以放在栈中存储。
引用数据类型：引用数据类型存储在堆内存中，存储的是地址，多个引用指向同一个地址，这里会设计一个‘共享’的概念，占据空间大，大小不固定。引用类型在栈中存储了指针，该指针指向堆中该实体的起始位置。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

# typeof
  对原始类型来说，除了null都可以显示正确。
  typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,
  所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof
# instance
  正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype

  instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；
  而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断.
# constructor
  如果我创建一个对象，更改它的原型，constructor就会变得不可靠了

# Object.prototype.toString.call()
  toString() 是 Object 的原型方法，调用该方法，可以统一返回格式为 “[object Xxx]” 的字符串，其中 Xxx 就是对象的类型。对于 Object 对象，直接调用 toString() 就能返回 [object Object]；而对于其他对象，则需要通过 call 来调用，才能返回正确的类型信息

# 总结
- typeof

直接在计算机底层基于数据类型的值（二进制）进行检测
typeof null为object 原因是对象存在在计算机中，都是以000开始的二进制存储，所以检测出来的结果是对象
typeof 普通对象/数组对象/正则对象/日期对象 都是object
typeof NaN === 'number'

- instanceof

检测当前实例是否属于这个类的
底层机制：只要当前类出现在实例的原型上，结果都是true
不能检测基本数据类型

- constructor

支持基本类型
constructor可以随便改，也不准

- Object.prototype.toString.call([val])

返回当前实例所属类信息

# javascript的作用域和作用域链
- 作用域： 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。
- 作用域链： 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和 函数。



