# TCP
1. 面向连接
2. 在数据传输过程中通过各种算法保证数据的可靠性
3. 有拥塞控制

# tcp头部字段
1. Sequence number,保证通过tcp传输的报文都是有序的，对方可以通过序号的顺序拼接报文。
2. Acknowledgement Number,表示数据接收端期望接受的下一个字节的编号是多少，同时也表示上一个数据已经接收到了
3. Window Size，窗口大小，表示还能接受多少数据，用于流量控制
4. 标识符
    - URG=1:该字段是本数据包里面的紧急信息，是一个高优先级的报文
    - ACK=1: 该字段表示确认号字段有效
    - PSH=1：该字段表示数据应该立即PUSH给应用层
    - RST=1：表示TCP连接出现问题，可能需要重连
    - SYN=1：当SYN=1，ACK=0时，表示报文段是一个连接请求；当SYN=1,ACK=1时，同意建立连接的应答报文。
    - FIN=1：用来释放连接的请求

# 三次握手 
    建立连接
    <!-- SYN-SEND -->
    客户端向服务端发送请求报文，发出请求SYN=1，同时选择一个初始序号seq=x

    LISTEN->SYNC-RCVD-->
    客户端的状态变成ESTABLISHED

    客户端接收到服务端的TCP建立验证请求后，向服务端给出确认

    服务端状态： ESTSBLISHED

    TCP告诉你：共鸣+具体话题

              共鸣+同意



# 为什么TCP建立连接需要三次握手，明明两次就可以建立连接?
    ？？
    第一次握手：客户端发送网络包，服务端收到了。
这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
第二次握手：服务端发包，客户端收到了。
这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
第三次握手：客户端发包，服务端收到了。
这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

因此，需要三次握手才能确认双方的接收与发送能力是否正常。
试想如果是用两次握手，则会出现下面这种情况：

如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。


# 四次挥手
断开连接

客户端向服务端发出连接释放报文，并且停止发送数据

<!-- CLODSE-Wait -->
服务器接收到连接释放报文后，发出确认报文

客户端进入FIN-WAIt-2

<!-- LAST_ACK -->
服务器把最后的信息发送完毕，就向客户端连接释放报文

客户端状态：TIME_WAIT

客户端收到服务端发出的连接释放报文后，必须发出确认

服务端状态： CLOSED

原地驻足等待2MSL->closed

# 为什么客户端要进入 TIME_WAIT状态，等待2MSL时间才进入CLOSE状态？
   为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。





