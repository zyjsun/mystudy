# 反转链表

## 通过前驱结点与后继结点的概念，使用遍历
    当前结点next 指向它的前驱结点
    之前的前驱结点变为当前结点
    当前结点变成原结点的后继结点
    如果为null ,完成遍历
## 递归
  - 把复杂的类似的变成简单的重复
  - 退出条件 null
  简单公式 n 个结点反转 1 个结点
  结点cur next 指向结点的next 指向当前结点的话，就反转了
结点next 属性干掉


# 奇偶链表
 错误的做法 ， 业务开发思维 ，暴力去术 ，哨兵结点，原地的
 0(n) 时间复杂度
 0(1) 空间复杂度

# js中的数据类型
原始数据类型 string number boolean null undefined Symbol(唯一)
引用类型 Object Array Function Date

栈 队列 链表 树
一般设计到对称 优先考虑栈结构


o(1)
o(n^n)
o(n!)
o(2^n)
o(n^2)
o(n*logn)
o(n)
o(logn)

# 数组
  fill 接收参数
  如果这个入参类型是引用类型，那么fill在填充的其实就是入参的引用
# 栈
  只能用pop和push完成增删的"数组"
# 队列
  只用push和shift完成增删的“数组”
# 链表
  

# 树
二叉树：
  1. 可以为空树
  2. 如果不是空树，那么就必须由根结点，左子树 和右子树组成
  3. 左右子树不能交换位置

- 遍历：
  1. 先序遍历
  2. 中序遍历
  3. 后序遍历
  4. 层次遍历
  1，2，3（递归遍历）
  （4）迭代遍历

1. 算法的复杂度分析
2. 排序算法，以及他们的区别和优化
3. 数组中的双指针，滑动窗口思想
4. 利用Map和Set来处理表的问题
5. 链表
6. 递归和迭代处理二叉树
7. 栈，队列
8. 回溯，贪心，动态规划